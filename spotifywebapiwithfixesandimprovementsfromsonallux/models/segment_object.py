# -*- coding: utf-8 -*-

"""
spotifywebapiwithfixesandimprovementsfromsonallux

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from spotifywebapiwithfixesandimprovementsfromsonallux.api_helper import APIHelper


class SegmentObject(object):

    """Implementation of the 'SegmentObject' model.

    Attributes:
        start (float): The starting point (in seconds) of the segment.
        duration (float): The duration (in seconds) of the segment.
        confidence (float): The confidence, from 0.0 to 1.0, of the
            reliability of the segmentation. Segments of the song which are
            difficult to logically segment (e.g: noise) may correspond to low
            values in this field.
        loudness_start (float): The onset loudness of the segment in decibels
            (dB). Combined with `loudness_max` and `loudness_max_time`, these
            components can be used to describe the "attack" of the segment.
        loudness_max (float): The peak loudness of the segment in decibels
            (dB). Combined with `loudness_start` and `loudness_max_time`,
            these components can be used to describe the "attack" of the
            segment.
        loudness_max_time (float): The segment-relative offset of the segment
            peak loudness in seconds. Combined with `loudness_start` and
            `loudness_max`, these components can be used to desctibe the
            "attack" of the segment.
        loudness_end (float): The offset loudness of the segment in decibels
            (dB). This value should be equivalent to the loudness_start of the
            following segment.
        pitches (List[float]): Pitch content is given by a “chroma” vector,
            corresponding to the 12 pitch classes C, C#, D to B, with values
            ranging from 0 to 1 that describe the relative dominance of every
            pitch in the chromatic scale. For example a C Major chord would
            likely be represented by large values of C, E and G (i.e. classes
            0, 4, and 7).  Vectors are normalized to 1 by their strongest
            dimension, therefore noisy sounds are likely represented by values
            that are all close to 1, while pure tones are described by one
            value at 1 (the pitch) and others near 0. As can be seen below,
            the 12 vector indices are a combination of low-power spectrum
            values at their respective pitch frequencies. ![pitch
            vector](https://developer.spotify.com/assets/audio/Pitch_vector.png
            )
        timbre (List[float]): Timbre is the quality of a musical note or sound
            that distinguishes different types of musical instruments, or
            voices. It is a complex notion also referred to as sound color,
            texture, or tone quality, and is derived from the shape of a
            segment’s spectro-temporal surface, independently of pitch and
            loudness. The timbre feature is a vector that includes 12
            unbounded values roughly centered around 0. Those values are high
            level abstractions of the spectral surface, ordered by degree of
            importance.  For completeness however, the first dimension
            represents the average loudness of the segment; second emphasizes
            brightness; third is more closely correlated to the flatness of a
            sound; fourth to sounds with a stronger attack; etc. See an image
            below representing the 12 basis functions (i.e. template
            segments). ![timbre basis
            functions](https://developer.spotify.com/assets/audio/Timbre_basis_
            functions.png)  The actual timbre of the segment is best described
            as a linear combination of these 12 basis functions weighted by
            the coefficient values: timbre = c1 x b1 + c2 x b2 + ... + c12 x
            b12, where c1 to c12 represent the 12 coefficients and b1 to b12
            the 12 basis functions as displayed below. Timbre vectors are best
            used in comparison with each other.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "start": 'start',
        "duration": 'duration',
        "confidence": 'confidence',
        "loudness_start": 'loudness_start',
        "loudness_max": 'loudness_max',
        "loudness_max_time": 'loudness_max_time',
        "loudness_end": 'loudness_end',
        "pitches": 'pitches',
        "timbre": 'timbre'
    }

    _optionals = [
        'start',
        'duration',
        'confidence',
        'loudness_start',
        'loudness_max',
        'loudness_max_time',
        'loudness_end',
        'pitches',
        'timbre',
    ]

    def __init__(self,
                 start=APIHelper.SKIP,
                 duration=APIHelper.SKIP,
                 confidence=APIHelper.SKIP,
                 loudness_start=APIHelper.SKIP,
                 loudness_max=APIHelper.SKIP,
                 loudness_max_time=APIHelper.SKIP,
                 loudness_end=APIHelper.SKIP,
                 pitches=APIHelper.SKIP,
                 timbre=APIHelper.SKIP):
        """Constructor for the SegmentObject class"""

        # Initialize members of the class
        if start is not APIHelper.SKIP:
            self.start = start 
        if duration is not APIHelper.SKIP:
            self.duration = duration 
        if confidence is not APIHelper.SKIP:
            self.confidence = confidence 
        if loudness_start is not APIHelper.SKIP:
            self.loudness_start = loudness_start 
        if loudness_max is not APIHelper.SKIP:
            self.loudness_max = loudness_max 
        if loudness_max_time is not APIHelper.SKIP:
            self.loudness_max_time = loudness_max_time 
        if loudness_end is not APIHelper.SKIP:
            self.loudness_end = loudness_end 
        if pitches is not APIHelper.SKIP:
            self.pitches = pitches 
        if timbre is not APIHelper.SKIP:
            self.timbre = timbre 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        start = dictionary.get("start") if dictionary.get("start") else APIHelper.SKIP
        duration = dictionary.get("duration") if dictionary.get("duration") else APIHelper.SKIP
        confidence = dictionary.get("confidence") if dictionary.get("confidence") else APIHelper.SKIP
        loudness_start = dictionary.get("loudness_start") if dictionary.get("loudness_start") else APIHelper.SKIP
        loudness_max = dictionary.get("loudness_max") if dictionary.get("loudness_max") else APIHelper.SKIP
        loudness_max_time = dictionary.get("loudness_max_time") if dictionary.get("loudness_max_time") else APIHelper.SKIP
        loudness_end = dictionary.get("loudness_end") if dictionary.get("loudness_end") else APIHelper.SKIP
        pitches = dictionary.get("pitches") if dictionary.get("pitches") else APIHelper.SKIP
        timbre = dictionary.get("timbre") if dictionary.get("timbre") else APIHelper.SKIP
        # Return an object of this model
        return cls(start,
                   duration,
                   confidence,
                   loudness_start,
                   loudness_max,
                   loudness_max_time,
                   loudness_end,
                   pitches,
                   timbre)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'start={(self.start if hasattr(self, "start") else None)!r}, '
                f'duration={(self.duration if hasattr(self, "duration") else None)!r}, '
                f'confidence={(self.confidence if hasattr(self, "confidence") else None)!r}, '
                f'loudness_start={(self.loudness_start if hasattr(self, "loudness_start") else None)!r}, '
                f'loudness_max={(self.loudness_max if hasattr(self, "loudness_max") else None)!r}, '
                f'loudness_max_time={(self.loudness_max_time if hasattr(self, "loudness_max_time") else None)!r}, '
                f'loudness_end={(self.loudness_end if hasattr(self, "loudness_end") else None)!r}, '
                f'pitches={(self.pitches if hasattr(self, "pitches") else None)!r}, '
                f'timbre={(self.timbre if hasattr(self, "timbre") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'start={(self.start if hasattr(self, "start") else None)!s}, '
                f'duration={(self.duration if hasattr(self, "duration") else None)!s}, '
                f'confidence={(self.confidence if hasattr(self, "confidence") else None)!s}, '
                f'loudness_start={(self.loudness_start if hasattr(self, "loudness_start") else None)!s}, '
                f'loudness_max={(self.loudness_max if hasattr(self, "loudness_max") else None)!s}, '
                f'loudness_max_time={(self.loudness_max_time if hasattr(self, "loudness_max_time") else None)!s}, '
                f'loudness_end={(self.loudness_end if hasattr(self, "loudness_end") else None)!s}, '
                f'pitches={(self.pitches if hasattr(self, "pitches") else None)!s}, '
                f'timbre={(self.timbre if hasattr(self, "timbre") else None)!s})')
