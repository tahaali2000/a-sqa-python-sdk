# -*- coding: utf-8 -*-

"""
spotifywebapiwithfixesandimprovementsfromsonallux

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from spotifywebapiwithfixesandimprovementsfromsonallux.api_helper import APIHelper
from spotifywebapiwithfixesandimprovementsfromsonallux.models.meta import Meta
from spotifywebapiwithfixesandimprovementsfromsonallux.models.section_object import SectionObject
from spotifywebapiwithfixesandimprovementsfromsonallux.models.segment_object import SegmentObject
from spotifywebapiwithfixesandimprovementsfromsonallux.models.time_interval_object import TimeIntervalObject
from spotifywebapiwithfixesandimprovementsfromsonallux.models.track import Track


class AudioAnalysisObject(object):

    """Implementation of the 'AudioAnalysisObject' model.

    Attributes:
        meta (Meta): The model property of type Meta.
        track (Track): The model property of type Track.
        bars (List[TimeIntervalObject]): The time intervals of the bars
            throughout the track. A bar (or measure) is a segment of time
            defined as a given number of beats.
        beats (List[TimeIntervalObject]): The time intervals of beats
            throughout the track. A beat is the basic time unit of a piece of
            music; for example, each tick of a metronome. Beats are typically
            multiples of tatums.
        sections (List[SectionObject]): Sections are defined by large
            variations in rhythm or timbre, e.g. chorus, verse, bridge, guitar
            solo, etc. Each section contains its own descriptions of tempo,
            key, mode, time_signature, and loudness.
        segments (List[SegmentObject]): Each segment contains a roughly
            conisistent sound throughout its duration.
        tatums (List[TimeIntervalObject]): A tatum represents the lowest
            regular pulse train that a listener intuitively infers from the
            timing of perceived musical events (segments).

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "meta": 'meta',
        "track": 'track',
        "bars": 'bars',
        "beats": 'beats',
        "sections": 'sections',
        "segments": 'segments',
        "tatums": 'tatums'
    }

    _optionals = [
        'meta',
        'track',
        'bars',
        'beats',
        'sections',
        'segments',
        'tatums',
    ]

    def __init__(self,
                 meta=APIHelper.SKIP,
                 track=APIHelper.SKIP,
                 bars=APIHelper.SKIP,
                 beats=APIHelper.SKIP,
                 sections=APIHelper.SKIP,
                 segments=APIHelper.SKIP,
                 tatums=APIHelper.SKIP):
        """Constructor for the AudioAnalysisObject class"""

        # Initialize members of the class
        if meta is not APIHelper.SKIP:
            self.meta = meta 
        if track is not APIHelper.SKIP:
            self.track = track 
        if bars is not APIHelper.SKIP:
            self.bars = bars 
        if beats is not APIHelper.SKIP:
            self.beats = beats 
        if sections is not APIHelper.SKIP:
            self.sections = sections 
        if segments is not APIHelper.SKIP:
            self.segments = segments 
        if tatums is not APIHelper.SKIP:
            self.tatums = tatums 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        meta = Meta.from_dictionary(dictionary.get('meta')) if 'meta' in dictionary.keys() else APIHelper.SKIP
        track = Track.from_dictionary(dictionary.get('track')) if 'track' in dictionary.keys() else APIHelper.SKIP
        bars = None
        if dictionary.get('bars') is not None:
            bars = [TimeIntervalObject.from_dictionary(x) for x in dictionary.get('bars')]
        else:
            bars = APIHelper.SKIP
        beats = None
        if dictionary.get('beats') is not None:
            beats = [TimeIntervalObject.from_dictionary(x) for x in dictionary.get('beats')]
        else:
            beats = APIHelper.SKIP
        sections = None
        if dictionary.get('sections') is not None:
            sections = [SectionObject.from_dictionary(x) for x in dictionary.get('sections')]
        else:
            sections = APIHelper.SKIP
        segments = None
        if dictionary.get('segments') is not None:
            segments = [SegmentObject.from_dictionary(x) for x in dictionary.get('segments')]
        else:
            segments = APIHelper.SKIP
        tatums = None
        if dictionary.get('tatums') is not None:
            tatums = [TimeIntervalObject.from_dictionary(x) for x in dictionary.get('tatums')]
        else:
            tatums = APIHelper.SKIP
        # Return an object of this model
        return cls(meta,
                   track,
                   bars,
                   beats,
                   sections,
                   segments,
                   tatums)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'meta={(self.meta if hasattr(self, "meta") else None)!r}, '
                f'track={(self.track if hasattr(self, "track") else None)!r}, '
                f'bars={(self.bars if hasattr(self, "bars") else None)!r}, '
                f'beats={(self.beats if hasattr(self, "beats") else None)!r}, '
                f'sections={(self.sections if hasattr(self, "sections") else None)!r}, '
                f'segments={(self.segments if hasattr(self, "segments") else None)!r}, '
                f'tatums={(self.tatums if hasattr(self, "tatums") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'meta={(self.meta if hasattr(self, "meta") else None)!s}, '
                f'track={(self.track if hasattr(self, "track") else None)!s}, '
                f'bars={(self.bars if hasattr(self, "bars") else None)!s}, '
                f'beats={(self.beats if hasattr(self, "beats") else None)!s}, '
                f'sections={(self.sections if hasattr(self, "sections") else None)!s}, '
                f'segments={(self.segments if hasattr(self, "segments") else None)!s}, '
                f'tatums={(self.tatums if hasattr(self, "tatums") else None)!s})')
